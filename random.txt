public class NotesDTO {
    private Map<String, String> notes;

    // Constructor, Getters and Setters
    public NotesDTO(Map<String, String> notes) {
        this.notes = notes;
    }

    public Map<String, String> getNotes() {
        return notes;
    }

    public void setNotes(Map<String, String> notes) {
        this.notes = notes;
    }
}


  @Autowired
    private RxSotGppDataRepository rxSotGppDataRepository;

    public NotesDTO fetchNotesBySotId(Long sotId) {
        RxSotGppData entity = rxSotGppDataRepository.findBySotId(sotId);
        
        // Assuming notes are stored as a JSON string, you would need to parse this JSON
        ObjectMapper mapper = new ObjectMapper();
        Map<String, String> notesMap;
        try {
            notesMap = mapper.readValue(entity.getNotes(), new TypeReference<Map<String, String>>(){});
        } catch (IOException e) {
            throw new RuntimeException("Error parsing notes", e);
        }

        // Sort notes by key, based on the number after "Notes"
        Map<String, String> sortedNotes = notesMap.entrySet().stream()
                .sorted(Comparator.comparing(e -> Integer.parseInt(e.getKey().replaceAll("\\D+", ""))))
                .collect(Collectors.toMap(
                        e -> "Note " + e.getKey().replaceAll("\\D+", ""), // Rename key to "Note 1", "Note 2", etc.
                        Map.Entry::getValue,
                        (oldValue, newValue) -> oldValue, LinkedHashMap::new));

        return new NotesDTO(sortedNotes);
    }
	
	
	--------------------------
	  public NotesDTO fetchNotesBySotId(Long sotId) {
        String notesJson = rxSotGppDataRepository.findNotesBySotId(sotId);
        
        // Assuming notes are stored as a JSON string, parse this JSON
        ObjectMapper mapper = new ObjectMapper();
        Map<String, String> notesMap;
        try {
            notesMap = mapper.readValue(notesJson, new TypeReference<Map<String, String>>() {});
        } catch (IOException e) {
            throw new RuntimeException("Error parsing notes", e);
        }

        // Sort notes by key, based on the number after "Notes"
        Map<String, String> sortedNotes = notesMap.entrySet().stream()
                .sorted(Comparator.comparing(e -> Integer.parseInt(e.getKey().replaceAll("\\D+", ""))))
                .collect(Collectors.toMap(
                        e -> "Note " + e.getKey().replaceAll("\\D+", ""), // Rename key to "Note 1", "Note 2", etc.
                        Map.Entry::getValue,
                        (oldValue, newValue) -> oldValue, LinkedHashMap::new));

        return new NotesDTO(sortedNotes);
    }
	-------------------------